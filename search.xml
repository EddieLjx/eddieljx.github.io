<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>语言模型在生物研究中的应用</title>
      <link href="/2024/10/18/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9C%A8%E7%94%9F%E7%89%A9%E7%A0%94%E7%A9%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2024/10/18/%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B%E5%9C%A8%E7%94%9F%E7%89%A9%E7%A0%94%E7%A9%B6%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Information"><a href="#Information" class="headerlink" title="Information"></a>Information</h1><table style="border: 2px solid #3fc1c1; border-collapse: collapse;">  <tr style="border: 2px solid #3fc1c1;">    <td colspan="3" style="text-align:center; border: 2px solid #3fc1c1;"><h2><a href="https://www.nature.com/articles/s41592-024-02354-y">Language models for biological research: a primer</a></h2></td>  </tr>  <tr style="border: 2px solid #3fc1c1;">    <td colspan="3" style="border: 2px solid #3fc1c1;"><h3>Author:</h3><b>Elana Simon, Kyle Swanson & James Zou</b></td>  </tr>  <tr style="border: 2px solid #3fc1c1;">    <td colspan="2" style="border: 2px solid #3fc1c1;"><h3>Jounal:</h3><b>Nature Methods</b></td>    <td style="border: 2px solid #3fc1c1;"><h3>Year:</h3><b>2024</b></td>  </tr></table><hr><h1 id="Methods-and-Backgrounds"><a href="#Methods-and-Backgrounds" class="headerlink" title="Methods and Backgrounds"></a>Methods and Backgrounds</h1><ol><li>Language Model: 语言模型可以学习序列中的复杂模式，例如句子中的单词和蛋白质中的氨基酸。由于这些模型大多是在异构序列集合上训练的，因此它们可以学习灵活的模式，并且可以适应性解决各种特定问题。由于其适应性，因此通常作为支持广泛下游应用程序的基础模型。其训练过程往往包括预训练和微调两个部分，其中对更大的数据集进行预训练(无监督)为模型提供了对数据的基本理解，从而能够在微调期间更有效地学习新目标。</li></ol><hr><h1 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h1><p>本文旨在介绍、回顾语言模型(基于Transformer架构)在生物学研究中的作用，其中预训练模型通过三种常见方法被用于研究：1.直接预测；2.embedding分析；3.迁移学习。</p><p style="text-align:center;"><img src="https://cdn.jsdelivr.net/gh/EddieLjx/BlogImg/LM_Review_NatureMethods/Fig1.png" style="zoom:50%;margin:0,auto;">Fig. 1: Approaches to using language models for biological research.</p><p>在本篇Primer中，作者介绍了如何使用这三种方法调整自然语言和生物语言模型来解决生物学中的一系列问题，以及使用语言模型进行生物学建模时的最佳实践，包括何时使用每种方法的建议以及给定当前模型限制需要考虑的注意事项。</p><hr><h1 id="Article-Details"><a href="#Article-Details" class="headerlink" title="Article Details"></a>Article Details</h1><h2 id="Natural-Language-Models"><a href="#Natural-Language-Models" class="headerlink" title="Natural Language Models"></a>Natural Language Models</h2><p>自然语言模型，例如ChatGPT，Claude之类的，在大量的数据集上训练，其中包括PubMed等生物来源。因此，它们可以微调为专业模型（例如，BioBERT或Med-PaLM2），为生物学研究者提供帮助。值得注意的是，因为ChatGPT、Claude这样的模型使用的训练数据集更广泛，因此其效果甚至可能优于Specialist的模型。</p><p>目前，自然语言模型可以大大加速生物学研究人员的效率，帮助阅读整理文献、总结文献中陌生概念，并可帮助完成生物信息学分析代码。</p><p style="text-align:center;"><img src="https://cdn.jsdelivr.net/gh/EddieLjx/BlogImg/LM_Review_NatureMethods/Fig2.png" style="zoom:50%;margin:0,auto;">Fig. 2: Example uses of natural language models for biological research.</p><h2 id="Biology-Language-Models"><a href="#Biology-Language-Models" class="headerlink" title="Biology Language Models"></a>Biology Language Models</h2><h3 id="Protein-Language-Models"><a href="#Protein-Language-Models" class="headerlink" title="Protein Language Models"></a>Protein Language Models</h3><h4 id="Importance-of-Large-scale-pretraining"><a href="#Importance-of-Large-scale-pretraining" class="headerlink" title="Importance of Large-scale pretraining"></a>Importance of Large-scale pretraining</h4><p>在蛋白质序列的大型数据集上预先训练的蛋白质语言模型可以学习捕获蛋白质进化约束和关键特性的表示。随后在较小的标记数据集上对这些模型进行微调，可以准确预测下游任务，例如稳定性、相互作用，甚至具有指定结构的序列设计。</p><h4 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h4><h5 id="Direct-Prediction"><a href="#Direct-Prediction" class="headerlink" title="Direct Prediction:"></a>Direct Prediction:</h5><p>根据这些模型的原始训练目标，可以使用这些模型直接预测每个氨基酸出现在序列中给定位置的概率。由于训练数据涵盖了已知功能性蛋白质序列的所有谱系，因此这些模型有效地学习了蛋白质进化的模式。如果不对突变的影响进行实验测量，该模型就可以隐式地了解哪些突变会对蛋白质功能有害，因为根据在整个进化过程中实证观察到的突变，它们被认为不太可能发生。因此，这些预测可以开箱即用地用于估计蛋白质编码突变的影响。</p><p>可以通过在给定位置特异性掩盖野生型氨基酸并要求模型在给定序列的其余部分来估算掩蔽位置来获得突变的可能性。如果根据语言模型，突变的可能性低于野生型氨基酸，则表明该突变可能是有害的。评估突变致病性的实验研究已经根据模型似然, 验证了这些估计。</p><p>将蛋白质序列建模为语言的一个好处是这些序列<b>不需要事先比对或注释</b>; 其他方法需要进化上对齐的蛋白质序列来预测突变的影响。蛋白质序列似然的语言模型估计也可用于估计蛋白质序列是否可能形成功能结构，这使得蛋白质语言模型能够评估和设计新的序列</p><h5 id="Embedding-Analysis"><a href="#Embedding-Analysis" class="headerlink" title="Embedding Analysis"></a>Embedding Analysis</h5><p>除了输出之外，蛋白质语言模型还提供有用的蛋白质嵌入。具体来说，当蛋白质序列通过模型运行时，可以提取模型对蛋白质中每个氨基酸的内部表示（嵌入）。然后，每个氨基酸的嵌入可以单独使用或组合成单个蛋白质表示。例如，先前的工作发现<b>聚类蛋白质序列嵌入可以识别同源蛋白质</b>。然后，可以根据每种蛋白质中单个氨基酸嵌入之间的相似性将这些同源蛋白构建成<b>多序列比对</b>。</p><h5 id="Transfer-Learning"><a href="#Transfer-Learning" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h5><p>由于微调蛋白质语言模型的成本很高，因此目前，更多的用法是将Embedding取出，输入给另一个更小的模型，以完成下游任务，例如：预测蛋白质稳定性、病毒抗原突变的免疫逃逸以及使用少量标记数据预测错义变体的致病性。或者，有更新、更高效的微调技术，使计算资源较少的研究人员能够完全微调大型蛋白质语言模型。</p><h4 id="Protein-Structure-Models"><a href="#Protein-Structure-Models" class="headerlink" title="Protein Structure Models"></a>Protein Structure Models</h4><p>虽然蛋白质结构预测模型，如 AlphaFold2和 ESMFold，不是本引物的重点，但值得一提的是，将结构信息与蛋白质序列一起包含在蛋白质序列中以训练模型，就像在蛋白质结构预测模型中所做的那样，可以改善各种下游任务的蛋白质表示。蛋白质结构预测模型与语言模型一样，已被证明可以通过直接预测、嵌入分析和迁移学习广泛适用于各种下游应用。</p><h3 id="Single-cell-Language-Models"><a href="#Single-cell-Language-Models" class="headerlink" title="Single-cell Language Models"></a>Single-cell Language Models</h3><h4 id="Importance-of-Large-scale-pretraining-1"><a href="#Importance-of-Large-scale-pretraining-1" class="headerlink" title="Importance of Large-scale pretraining"></a>Importance of Large-scale pretraining</h4><p>单细胞基因表达数据提供了对单个细胞的细胞状态和功能的见解，但它们的高维性使解释具有挑战性。最近开发了 AI 方法来帮助分析这些复杂数据。公开可用的单细胞基因表达数据的增长允许在不同细胞类型、组织、生物体和实验条件下的数百万个转录组上训练语言模型。这些模型可以泛化到新的数据集，并且可以针对各种下游任务进行微调，包括单元类型注释和批量校正。</p><h4 id="Example-Geneformer"><a href="#Example-Geneformer" class="headerlink" title="Example: Geneformer"></a>Example: Geneformer</h4><p><a href="https://www.nature.com/articles/s41586-023-06139-9">Geneformer</a>就是这样一种单细胞语言模型。与许多其他生物语言模型一样，它具有经过训练的 transformer 架构，可为许多下游应用提供基因和细胞的表示。Geneformer 将<b>每个细胞表示为细胞中表达量最大的 2,048 个基因的列表</b>，根据 RNA 表达水平排序。训练过程与前面描述的蛋白质语言模型类似，因为基因的子集被掩盖，模型被训练以预测缺失的基因。为了按照表达水平的顺序正确预测缺失的基因，该模型必须<b>了解各种基因的表达水平之间的相互作用，并隐式学习细胞类型特异性模式和背景</b>。Geneformer 在跨越 40 种组织类型的 3000 万个单细胞转录组上进行了训练，这有助于它学习不同的表达模式。尽管 Geneformer 关注每个基因的相对表达水平，但其他单细胞语言模型使用替代公式。例如，单细胞语言模型 <a href="https://www.nature.com/articles/s41592-024-02201-0">scGPT</a>对定量表达值进行了预训练，从而实现了略有不同的下游应用。scGPT 还可以包括实验元数据，例如模态、批次和扰动条件。</p><h4 id="Application-1"><a href="#Application-1" class="headerlink" title="Application"></a>Application</h4><h5 id="Direct-Prediction-1"><a href="#Direct-Prediction-1" class="headerlink" title="Direct Prediction:"></a>Direct Prediction:</h5><p>单细胞语言模型的直接输出支持各种创造性的计算机实验。该模型可以通过获取单个细胞中按表达排序的原始基因列表、修改基因的顺序并量化这如何改变输出来估计遗传扰动对细胞的影响。例如，Geneformer 通过人为地将POU5F1、SOX2、KLF4 和 MYC 添加到细胞基因排名的顶部来模拟成纤维细胞的重编程，从而在计算上将细胞转移到诱导多能干细胞状态。同样，单细胞语言模型可以通过人为地从细胞的排名列表中删除基因并检查对细胞嵌入的影响来预测细胞对基因去除的敏感性。</p><h5 id="Embedding-Analysis-1"><a href="#Embedding-Analysis-1" class="headerlink" title="Embedding Analysis"></a>Embedding Analysis</h5><p>单细胞语言模型包含每个基因的嵌入，这些嵌入可以组合（例如，平均）以为每个细胞创建一个表示。这些细胞嵌入可用于聚类、可视化和细胞类型标记。由于训练数据的多样性和数量，这些模型可以在保持生物变异性的同时隐式减少批次效应，使它们能够从包含许多实验批次的数据集中识别细微的细胞亚型。</p><h5 id="Transfer-Learning-1"><a href="#Transfer-Learning-1" class="headerlink" title="Transfer Learning"></a>Transfer Learning</h5><p>尽管这些嵌入中可能会出现有意义的簇，例如细胞类型，但也可以对模型进行微调以预测单个细胞的特性。例如，可以微调单细胞语言模型，以整合跨实验条件的数据并预测细胞类型标签和细胞状态。它们甚至可以支持基因的多模态表示。例如，可以对 scGPT 进行微调，以包括染色质可及性和蛋白质丰度以及基因表达水平，从而实现跨模态的数据集集成。</p><h2 id="Multimodal-Language-Models-for-Biology"><a href="#Multimodal-Language-Models-for-Biology" class="headerlink" title="Multimodal Language Models for Biology"></a>Multimodal Language Models for Biology</h2><p>多模态模型可以跨多种数据模态（例如文本和图像）进行推理，从而使这些模型能够解决本质上涉及多种数据类型的任务。例如，病理学语言-图像预训练 （PLIP）在 Twitter 数据上进行了训练，以将病理图像与其字幕相匹配，使用户能够获取给定图像的字幕或查找给定文本描述的图像。同样，Med-PaLM Multimodal被训练为基于生物医学图像回答问题，而 MolT5被训练为根据分子结构用自然语言描述分子，包括有关其潜在生物学功能的信息。给定具有多种模态的数据点的足够示例，研究人员也可以为其他类型的生物数据训练多模态模型。</p><p>通过将生物文本的固定语言模型嵌入与来自其他领域的数据相结合，自然语言模型也可以应用于多模态设置，而无需额外训练。GenePT 为单细胞数据提供了一个示例。GenePT 利用语言模型的隐含基因组知识来嵌入细胞。具体来说，GenePT 使用 ChatGPT 嵌入细胞，首先使用 ChatGPT 嵌入来自 NCBI 的基因的文本描述，然后通过平均基于文本的基因嵌入来创建单细胞嵌入，按单细胞表达加权。在某些应用程序中，这些从自然语言模型派生的嵌入与来自生物语言模型（如 Geneformer）的嵌入相匹配或优于生物语言模型。类似的想法可以应用于生物学的其他领域;固定语言模型嵌入可以与来自替代模态的数据或模型合并，而无需额外训练。</p><h2 id="Best-practices-when-using-language-models-for-biology"><a href="#Best-practices-when-using-language-models-for-biology" class="headerlink" title="Best practices when using language models for biology"></a>Best practices when using language models for biology</h2><p style="text-align:center;"><img src="https://cdn.jsdelivr.net/gh/EddieLjx/BlogImg/LM_Review_NatureMethods/Fig3.png" style="zoom:50%;margin:0,auto;">Fig. 3: Choosing the right approach for adapting a language model.</p><p>第一个决定是确定研究问题的目标。如果目标是数据探索，则可以使用嵌入分析方法以及降维和聚类等技术来揭示数据中的结构。但是，如果目标是根据数据进行预测，那么直接预测和迁移学习方法往往更有用。如果问题根据模型的训练数据和目标与模型的内在能力相匹配，那么直接预测方法是合适的，可能会根据目标修改输入。如果项目目标明显偏离模型的能力，或者如果有更特定于感兴趣任务的数据，那么迁移学习可能很有用。当有足够的数据和计算资源可用时，最好的方法可能是微调部分或全部语言模型。但是，如果数据或计算资源有限，另一种方法是使用语言模型计算新数据点的嵌入，并使用这些嵌入作为输入来训练单独的、通常较小的模型。此外，某些模型仅作为 Web 界面或应用程序编程接口 （API） 提供，这可能会限制其用于直接预测。其他具有开源代码和经过训练的模型参数的模型可用于嵌入分析或迁移学习。<br><div class="note disabled blue flat"><p><div class="tip "><p><a href="https://www.nature.com/articles/s41592-024-02354-y/tables/2">Biological language model resources</a></p></div><br>一些模型还附带了 Jupyter 笔记本或 Google Colab 笔记本，演示了如何将预训练模型用于各种应用程序。该表罗列了它们中的部分。</p></div></p><p>尽管语言模型可能非常强大，但它们具有用户应注意的重要限制。首先，语言模型仍然无法完美地解决许多生物问题，即使是它们最初被训练要解决的问题。这可能是由于模型的限制，这些模型可能无法学习控制训练数据的所有模式，以及训练数据的限制。训练数据可能过时或有干扰，并且在某些类型的数据代表性不足的情况下，它们可能存在差距。例如，自然语言模型仅包含其训练数据中包含的生物知识，因此它们将不知道训练后发现的发现。蛋白质语言模型通常在标准氨基酸上进行训练，因此无法反映输入表示中任何翻译后修饰的重要性。单细胞表达数据可能很嘈杂，而资金优先级可能会使数据量偏向于特定的组织类型和疾病状态，这两者都是影响模型性能的因素。</p><p>此外，为特定生物应用量身定制的模型有时仍优于生物语言模型，尤其是当先验知识可以为模型设计提供信息时。例如，包含蛋白质结构信息的方法已被证明优于使用在蛋白质序列上训练的语言模型的方法。最后，评估适应其他任务的语言模型的性能也需要小心。语言模型是在大量可能不会公开共享的数据上进行训练的，因此确保语言模型的训练数据与下游任务的测试数据之间没有数据泄漏可能具有挑战性。</p>]]></content>
      
      
      <categories>
          
          <category> 文献阅读📖 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNA-seq分析流程</title>
      <link href="/2024/05/22/RNA-seq%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B/"/>
      <url>/2024/05/22/RNA-seq%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>记录一下学习RNA-seq分析的过程，整体流程参考，可能会补充一些其他的资料：</p><p><style><br>refer .a {<br>    color: white;<br>    font-size: 8px;<br>    text-decoration: none;<br>}</p><p>refer a:hover {<br>    color: blue;<br>}<br>&lt;/style&gt;</p><refer><ul><li> <a href="https://zhuanlan.zhihu.com/p/518132262">RNA-seq入门实战（零）：RNA-seq流程前的准备——Linux与R的环境创建</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518134934">RNA-seq入门实战（一）：上游数据下载、格式转化和质控清洗</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518137593">RNA-seq入门实战（二）：上游数据的比对计数——Hisat2+ featureCounts 与 Salmon</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518140221">RNA-seq入门实战（三）：从featureCounts与Salmon输出文件获取counts矩阵</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518141288">RNA-seq入门实战（四）：差异分析前的准备——数据检查</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518142469">RNA-seq入门实战（五）：差异分析——DESeq2 edgeR limma的使用与比较</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518143539">RNA-seq入门实战（六）：GO、KEGG富集分析与enrichplot超全可视化攻略</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518144716">RNA-seq入门实战（七）：GSEA——基因集富集分析</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518145829">RNA-seq入门实战（八）：GSVA——基因集变异分析</a></li><li> <a href="https://zhuanlan.zhihu.com/p/532037554">RNA-seq入门实战（九）：PPI蛋白互作网络构建（上）——STRING数据库的使用</a></li><li> <a href="https://zhuanlan.zhihu.com/p/532038640">RNA-seq入门实战（十）：PPI蛋白互作网络构建（下）——Cytoscape软件的使用</a></li><li> <a href="https://zhuanlan.zhihu.com/p/532039670">RNA-seq入门实战（十一）：WGCNA加权基因共表达网络分析——关联基因模块与表型</a></li></ul></refer><h1 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h1><hr><h1 id="上游数据下载、获取和质控分析"><a href="#上游数据下载、获取和质控分析" class="headerlink" title="上游数据下载、获取和质控分析"></a>上游数据下载、获取和质控分析</h1><h2 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h2><p>Source：NCBI-&gt;GEO数据库-&gt;SRA Run Select  <br><br>Packge: Linux Sra-tools prefetch方法    <br><br>Output: SRA数据<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefetch -O ./ $id &amp;</span><br></pre></td></tr></table></figure><br><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>-O ： 下载目录</li><li>id : 下载数据SRA号，例：SRR12207280</li></ul>              </div>            </details></p><h2 id="SRA数据转fastq"><a href="#SRA数据转fastq" class="headerlink" title="SRA数据转fastq"></a>SRA数据转fastq</h2><p>Packge: Linux Sra-tools fasterq-dump/fastq-dump<br><br>    fasterq-dump速度更快，但不支持<code>--gzip</code><br><br>Input: *.sra    <br><br>Output: .fastq / .fastq.gz<br><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastq-dump --gzip --split-3 -O $&#123;outdirectory&#125; $&#123;SRRxxx&#125;.sra</span><br></pre></td></tr></table></figure><br><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>—gzip: 输出gz格式压缩文件</li><li>—split-spot: 将双端测序分为两份,但是都放在同一个文件中</li><li>—split-files: 将双端测序分为两份,放在不同的文件,但是对于一方有而一方没有的reads直接丢弃</li><li>—split-3: 默认值，将双端测序分为两份,放在不同的文件,但是对于一方有而一方没有的reads会单独放在一个文件夹里</li></ul>              </div>            </details><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fasterq-dump  -p -e 24 --split-3 -O $&#123;outdirectory&#125; $&#123;SRRxxx&#125;.sra</span><br></pre></td></tr></table></figure><br><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>-P: 可以显示进程 </li><li>-e: 使用线程数目<br>note： —gzip不可用！！</li></ul>              </div>            </details><br>参考：<br><br><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1] "></span><a class="reference-anchor" href="#referto_[1] ">[1] <div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href=" https://zhuanlan.zhihu.com/p/591140275"> sra转fastq笔记</a></div></p><hr><h2 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h2><h3 id="原始数据质量查看"><a href="#原始数据质量查看" class="headerlink" title="原始数据质量查看"></a>原始数据质量查看</h3><h4 id="fastqc"><a href="#fastqc" class="headerlink" title="fastqc"></a>fastqc</h4><p>一款快速多线程地对测序数据进行质量评估（Quality Control）的质控软件，将生成html报告和报告压缩文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastqc [-o output dir] [--(no)extract] [-f fastq|bam|sam] [-c contaminant file] seqfile1 .. seqfileN</span><br></pre></td></tr></table></figure><br><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>-o: 输出目录</li><li>-noextract: 生成的报告默认会打包成1个压缩文件，使用这个参数是让程序不打包</li><li>-f: 强制输入文件格式，默认自动检测，有效输入bam,sam,bam_mapped,sam_mapped and fastq</li><li>-t: 线程数</li><li>-q: 安静运行模式</li></ul>              </div>            </details></p><h4 id="multiqc"><a href="#multiqc" class="headerlink" title="multiqc"></a>multiqc</h4><p>一种模块化工具，用于将多个样本的质量控制分析结果汇总到一份报告中，同样会生成html报告<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multiqc [file_dir] --ignore [ignore_file]</span><br></pre></td></tr></table></figure><br><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>[file_dir]:输入qc结果文件夹，将自动分析文件夹下的全部目录</li><li>[ignore_file]:</li></ul>              </div>            </details><br>原始数据质量判断戳这儿<br><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href=" https://zhuanlan.zhihu.com/p/57628300"> fastqc报告查看</a></div><br><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href=" https://www.jianshu.com/p/f83626fd1fa1"> multiqc报告查看</a></div></p><h3 id="质控清洗"><a href="#质控清洗" class="headerlink" title="质控清洗"></a>质控清洗</h3><h4 id="trim-galore"><a href="#trim-galore" class="headerlink" title="trim-galore"></a>trim-galore</h4><p>Trim Galore是对FastQC和Cutadapt的包装,适用于所有高通量测序，包括RRBS(Reduced Representation Bisulfite-Seq ), Illumina、Nextera和smallRNA测序平台的双端和单端数据，包括去除低质量碱基和3’ 末端的adapter以及长度控制等功能。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">trim_galore -j 4  -q 25  --phred33 --length 35 \</span><br><span class="line">    --stringency 3  --paired --gzip -o [output_path] [file1] [file2]</span><br></pre></td></tr></table></figure><br><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>-j: 使用线程数, 注意假设已使用Python 3并安装了Pigz，那么内核设置为4，实际使用内核是15，因此，最高设为4.</li><li>-1：设定Phred quality score阈值，默认为Phred 20 切除质量得分低于设定值的序列</li><li>—phred33/—phred64： 用于指定输入数据的质量得分编码方式，ASCII 33 是由 Illumina 1.8+ 和 Sanger 测序平台使用的，而 ASCII 64 是由 Illumina 1.3+ 和 Illumina 1.5+ 测序平台使用的，可以用FastQC检查类型。</li><li>—length: 设定输出reads长度阈值小于设定值会被抛弃，默认值20bp。</li><li>—stringency: </li><li>—paired：指定输入数据是配对端（paired-end）测序数据，如若是单端测序则不需此参数</li><li>—gzip：清洗后的数据zip打包</li><li>-o：输出路径</li><li>— trim-n：移除read一端的reads</li><li>—fastqc：使用默认选项对结果文件进行fastqc分析</li></ul>              </div>            </details></p><hr><h1 id="上游数据比对、计数"><a href="#上游数据比对、计数" class="headerlink" title="上游数据比对、计数"></a>上游数据比对、计数</h1><h2 id="hisat2-featurecount"><a href="#hisat2-featurecount" class="headerlink" title="hisat2+featurecount"></a>hisat2+featurecount</h2><h3 id="hisat2比对"><a href="#hisat2比对" class="headerlink" title="hisat2比对"></a>hisat2比对</h3><p>HISAT2是一种用于比对RNA序列数据的工具，在使用之前需要先在<a href="https://daehwankimlab.github.io/hisat2/download/">获取索引文件</a>，或通过fasta文件自行建立。&lt;/br&gt;<br>索引文件的主要作用是加速比对过程。如果没有索引，HISAT2 需要对每一个读取和参考基因组的每一个位置进行比较，这将需要大量的时间。有了索引，HISAT2 可以快速地找到可能的比对位置，大大减少了比对所需的时间。此外，索引文件还可以包含其他的信息，如剪接位点（splice sites）和转录起始位点（transcription start sites）。这些信息可以帮助HISAT2更准确地比对RNA序列数据。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hisat2 -t -p 12 -x  [index] \</span><br><span class="line">-1 [file1]  \</span><br><span class="line">-2  [file2]  -S  [output.sam]</span><br></pre></td></tr></table></figure><br><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>-x：参考基因组/转录组文件前缀数，若文件形如genome.1.ht2、genome.2.ht2，则只需要genome作为参数则可。</li><li>-1/-2：双端测序的第一二组文件，如果有多组数据，用逗号分隔</li><li>-U：单端测序数据</li><li>–sra-acc：SRA_ID，Hisat将自动下载并比对</li><li>-S：输出路径</li><li>-p：线程数</li></ul>              </div>            </details></p><h3 id="samtools处理"><a href="#samtools处理" class="headerlink" title="samtools处理"></a>samtools处理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">samtools sort -@ 12 -o  id_sorted.bam  id.sam</span><br><span class="line">samtools index  -@  12  &#123;&#125;</span><br><span class="line">samtools flagstat -@ 12 id.bam &gt; id.flagstat</span><br></pre></td></tr></table></figure><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>sort 排序</li><li>index 建立索引</li><li>flagstat 统计 BAM 文件中的比对结果<br>摆烂了 先不管这个的参数了</li></ul>              </div>            </details><h3 id="featureCounts-计数得到counts表达矩阵"><a href="#featureCounts-计数得到counts表达矩阵" class="headerlink" title="featureCounts 计数得到counts表达矩阵"></a>featureCounts 计数得到counts表达矩阵</h3><p>gtf索引获取网址(注意和之前的hisat2索引对应)：</p><ul><li><a href="https://www.gencodegenes.org/">GENCODE</a></li><li><a href="https://hgdownload.soe.ucsc.edu/downloads.html">UCSC Genome</a></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">统计比对到每个genomic feature（外显子、基因等）中的<span class="built_in">read</span>数目</span></span><br><span class="line">featureCounts -T  12  -p  -a  xx.gtf.gz  -o  counts.txt  *.bam</span><br></pre></td></tr></table></figure><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>-T: 线程数目</li><li>-p：只能用在paired-end的情况中，会统计fragment的特征而非read的</li><li>-a: 参考gtf文件名，支持Gzipped文件格式</li><li>-M: 统计多重map的read</li><li>-J：统计可变剪切</li><li>-G：当-J设置的时候，通过-G提供一个比对的时候使用的参考基因组文件，辅助寻找可变剪切</li></ul>              </div>            </details><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href=" https://www.jianshu.com/p/9cc4e8657d62"> featurecounts的使用说明</a></div><h2 id="salmon-采用伪比对，直接对基因定量"><a href="#salmon-采用伪比对，直接对基因定量" class="headerlink" title="salmon-采用伪比对，直接对基因定量"></a>salmon-采用伪比对，直接对基因定量</h2><p>与hisat2不同，salmon不经过比对计数步骤而是直接对基因进行定量，如果不研究新转录本，用salmon方法可以更快更方便得到基因定量信息。按我自己的理解应该是hisat2是对全基因组进行比对，而salmon只对已知的基因注释比对。</p><h3 id="建立salmon索引"><a href="#建立salmon索引" class="headerlink" title="建立salmon索引"></a>建立salmon索引</h3><p>在<a href="https://ftp.ensembl.org/pub/release-102/fasta/">ENSEMBL官网</a>获取cDNA参考文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salmon index -t transcripts.fa -i transcripts_index -k 31</span><br></pre></td></tr></table></figure><br><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>-t：转录本的fasta文件</li><li>-i：输出目录</li><li>-k：K-mers，默认值为31<h1 id="如果你的reads大于75bp，那么k设置为31是较好的选择，如果reads低于75可略微减少K值"><a href="#如果你的reads大于75bp，那么k设置为31是较好的选择，如果reads低于75可略微减少K值" class="headerlink" title="如果你的reads大于75bp，那么k设置为31是较好的选择，如果reads低于75可略微减少K值"></a>如果你的reads大于75bp，那么k设置为31是较好的选择，如果reads低于75可略微减少K值</h1></li></ul>              </div>            </details></p><h3 id="salmon定量"><a href="#salmon定量" class="headerlink" title="salmon定量"></a>salmon定量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">双端测序数据reads表达量的估计</span></span><br><span class="line">salmon quant -i transcripts_index -l &lt;LIBTYPE&gt; -1 reads1.fq -2 reads2.fq -o transcripts_quant</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">单端测序数据reads表达量的估计</span></span><br><span class="line">salmon quant -i transcripts_index -l &lt;LIBTYPE&gt; -r reads.fq -o transcripts_quant</span><br></pre></td></tr></table></figure><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>-i：index</li><li>-1/2：双端数据</li><li>-r：单端数据</li><li>-l：—libType，测序文库类型，用A指定automatically determine</li></ul>              </div>            </details><h3 id="获取基因ID转化的对应文件"><a href="#获取基因ID转化的对应文件" class="headerlink" title="获取基因ID转化的对应文件"></a>获取基因ID转化的对应文件</h3><p>原文-&gt;<a href="https://www.jianshu.com/p/9e62f9148932">Here</a><br>由于本次使用的为gencode或ensembl的gtf与cdna文件，因此最后得到的为ensembl_id (gene_id)和 transcript_id，形式为：ENSMUSG00000000001.1 ，而我们下游常用gene symbol进行展示，因此还需要从gtf注释文件中获取ensembl_id 、transcript_id与gene symbol的对应关系文件。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">提取gtf注释文件中gene_id等与gene_name的对应关系,便于下游<span class="built_in">id</span>转换</span></span><br><span class="line">gtf=&quot;gencode.vM25.chr_patch_hapl_scaff.annotation.gtf&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## gene_id to gene_name</span></span></span><br><span class="line">grep &#x27;gene_id&#x27; $gtf | awk -F &#x27;gene_id \&quot;&#x27; &#x27;&#123;print $2&#125;&#x27; |awk -F &#x27;\&quot;&#x27; &#x27;&#123;print $1&#125;&#x27; &gt;gene_id_tmp</span><br><span class="line">grep &#x27;gene_id&#x27; $gtf | awk -F &#x27;gene_name \&quot;&#x27; &#x27;&#123;print $2&#125;&#x27; |awk -F &#x27;\&quot;&#x27; &#x27;&#123;print $1&#125;&#x27; &gt;gene_name_tmp</span><br><span class="line">paste gene_id_tmp gene_name_tmp &gt;last_tmp</span><br><span class="line">uniq last_tmp &gt;g2s_vm25_gencode.txt</span><br><span class="line">rm *_tmp</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">## transcript_id to gene_name</span></span></span><br><span class="line">grep &#x27;transcript_id&#x27; $gtf | awk -F &#x27;transcript_id \&quot;&#x27; &#x27;&#123;print $2&#125;&#x27; |awk -F &#x27;\&quot;&#x27; &#x27;&#123;print $1&#125;&#x27; &gt;gene_id_tmp</span><br><span class="line">grep &#x27;transcript_id&#x27; $gtf | awk -F &#x27;gene_name \&quot;&#x27; &#x27;&#123;print $2&#125;&#x27; |awk -F &#x27;\&quot;&#x27; &#x27;&#123;print $1&#125;&#x27; &gt;gene_name_tmp</span><br><span class="line">paste gene_id_tmp gene_name_tmp &gt;last_tmp</span><br><span class="line">uniq last_tmp &gt;t2s_vm25_gencode.txt</span><br><span class="line">rm *_tmp</span><br></pre></td></tr></table></figure></p><h2 id="从featureCounts输出文件中获取counts矩阵"><a href="#从featureCounts输出文件中获取counts矩阵" class="headerlink" title="从featureCounts输出文件中获取counts矩阵"></a>从featureCounts输出文件中获取counts矩阵</h2><h3 id="从GEO上获取SraRunTable后，读取counts并读取分组信息"><a href="#从GEO上获取SraRunTable后，读取counts并读取分组信息" class="headerlink" title="从GEO上获取SraRunTable后，读取counts并读取分组信息"></a>从GEO上获取SraRunTable后，读取counts并读取分组信息</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>data.table<span class="punctuation">)</span></span><br><span class="line">counts_file <span class="operator">&lt;-</span> <span class="string">&quot;./data/count/counts.txt&quot;</span></span><br><span class="line">rawcounts <span class="operator">&lt;-</span> fread<span class="punctuation">(</span>counts_file<span class="punctuation">,</span>header <span class="operator">=</span> <span class="built_in">T</span><span class="punctuation">,</span>data.table <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span> <span class="comment">#header=T-&gt;第一列是列名</span></span><br><span class="line">colnames<span class="punctuation">(</span>rawcounts<span class="punctuation">)</span></span><br><span class="line">counts <span class="operator">&lt;-</span> rawcounts<span class="punctuation">[</span><span class="punctuation">,</span><span class="number">7</span><span class="operator">:</span>ncol<span class="punctuation">(</span>rawcounts<span class="punctuation">)</span><span class="punctuation">]</span> <span class="comment">#截取样本基因表达量的counts部分作为counts </span></span><br><span class="line">rownames<span class="punctuation">(</span>counts<span class="punctuation">)</span> <span class="operator">&lt;-</span> rawcounts<span class="operator">$</span>Geneid</span><br><span class="line">colnames<span class="punctuation">(</span>counts<span class="punctuation">)</span></span><br><span class="line"><span class="comment">#gsub(&#x27;被替换的&#x27;,&#x27;替换&#x27;,data) 将data中的&#x27;被替换的&#x27;全部换成&#x27;替换&#x27;，如果为&#x27;&#x27;则等价于删去</span></span><br><span class="line">colnames<span class="punctuation">(</span>counts<span class="punctuation">)</span> <span class="operator">&lt;-</span> gsub<span class="punctuation">(</span><span class="string">&#x27;/XXX/RNA-seq/data/align/&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;&#x27;</span><span class="punctuation">,</span><span class="comment">#删除样品名前缀</span></span><br><span class="line">                    gsub<span class="punctuation">(</span><span class="string">&#x27;_sorted.bam&#x27;</span><span class="punctuation">,</span><span class="string">&#x27;&#x27;</span><span class="punctuation">,</span>  colnames<span class="punctuation">(</span>counts<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="comment">#删除样品名后缀</span></span><br><span class="line">runtable <span class="operator">&lt;-</span> fread<span class="punctuation">(</span><span class="string">&quot;./data/SraRunTable&quot;</span><span class="punctuation">)</span> <span class="comment">#从GEO上下载的metadata，包括每个样本的元数据信息，例如样本的处理条件、生物学重复、疾病状态等。</span></span><br><span class="line">name_list <span class="operator">&lt;-</span> runtable<span class="operator">$</span>source_name<span class="punctuation">[</span>match<span class="punctuation">(</span>colnames<span class="punctuation">(</span>counts<span class="punctuation">)</span><span class="punctuation">,</span>runtable<span class="operator">$</span>Run<span class="punctuation">)</span><span class="punctuation">]</span></span><br><span class="line"><span class="comment">#为分组编号</span></span><br><span class="line">name_list <span class="operator">&lt;-</span> paste0<span class="punctuation">(</span>name_list<span class="punctuation">,</span> <span class="string">&quot;_&quot;</span><span class="punctuation">,</span> ave<span class="punctuation">(</span><span class="built_in">rep</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span><span class="built_in">c</span><span class="punctuation">(</span><span class="built_in">length</span><span class="punctuation">(</span>name_list<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span> name_list<span class="punctuation">,</span> FUN <span class="operator">=</span> <span class="built_in">seq_along</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">group_list <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;naive&quot;</span><span class="punctuation">,</span><span class="string">&quot;naive&quot;</span><span class="punctuation">,</span><span class="string">&quot;primed&quot;</span><span class="punctuation">,</span><span class="string">&quot;primed&quot;</span><span class="punctuation">)</span></span><br><span class="line">batchinfo <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>row.names<span class="operator">=</span>colnames<span class="punctuation">(</span>counts<span class="punctuation">)</span><span class="punctuation">,</span></span><br><span class="line">                   name_list<span class="operator">=</span>name_list<span class="punctuation">,</span></span><br><span class="line">                   group_list<span class="operator">=</span>group_list<span class="punctuation">)</span></span><br><span class="line">colnames<span class="punctuation">(</span>counts<span class="punctuation">)</span> <span class="operator">&lt;-</span> name_list</span><br><span class="line">groupinfo <span class="operator">&lt;-</span> data.frame<span class="punctuation">(</span>row.names<span class="operator">=</span>colnames<span class="punctuation">(</span>counts<span class="punctuation">)</span><span class="punctuation">,</span> <span class="comment">#构建样品名与分组对应的数据框</span></span><br><span class="line">                 group_list<span class="operator">=</span>group_list<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="将counts原始矩阵转换为TPM"><a href="#将counts原始矩阵转换为TPM" class="headerlink" title="将counts原始矩阵转换为TPM"></a>将counts原始矩阵转换为TPM</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#提取Geneid、Length(转录本长度)</span></span><br><span class="line">geneid_efflen <span class="operator">&lt;-</span> subset<span class="punctuation">(</span>rawcounts<span class="punctuation">,</span>select <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Geneid&quot;</span><span class="punctuation">,</span><span class="string">&quot;Length&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">colnames<span class="punctuation">(</span>geneid_efflen<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;geneid&quot;</span><span class="punctuation">,</span><span class="string">&quot;efflen&quot;</span><span class="punctuation">)</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">### 取出counts中geneid对应的efflen</span></span><br><span class="line">efflen <span class="operator">&lt;-</span> geneid_efflen<span class="punctuation">[</span>match<span class="punctuation">(</span>rownames<span class="punctuation">(</span>counts<span class="punctuation">)</span><span class="punctuation">,</span>geneid_efflen<span class="operator">$</span>geneid<span class="punctuation">)</span><span class="punctuation">,</span><span class="string">&quot;efflen&quot;</span><span class="punctuation">]</span></span><br><span class="line">counts2TPM <span class="operator">&lt;-</span> <span class="keyword">function</span><span class="punctuation">(</span>count<span class="operator">=</span>count<span class="punctuation">,</span> efflength<span class="operator">=</span>efflen<span class="punctuation">)</span><span class="punctuation">&#123;</span></span><br><span class="line">  RPK <span class="operator">&lt;-</span> count<span class="operator">/</span><span class="punctuation">(</span>efflength<span class="operator">/</span><span class="number">1000</span><span class="punctuation">)</span>   <span class="comment">#每千碱基reads (Reads Per Kilobase) 长度标准化</span></span><br><span class="line">  PMSC_rpk <span class="operator">&lt;-</span> <span class="built_in">sum</span><span class="punctuation">(</span>RPK<span class="punctuation">)</span><span class="operator">/</span><span class="number">1e6</span>        <span class="comment">#RPK的每百万缩放因子 (“per million” scaling factor ) 深度标准化</span></span><br><span class="line">  RPK<span class="operator">/</span>PMSC_rpk              </span><br><span class="line"><span class="punctuation">&#125;</span>  </span><br><span class="line"></span><br><span class="line">tpm <span class="operator">&lt;-</span> as.data.frame<span class="punctuation">(</span>apply<span class="punctuation">(</span>counts<span class="punctuation">,</span><span class="number">2</span><span class="punctuation">,</span>counts2TPM<span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line">colSums<span class="punctuation">(</span>tpm<span class="punctuation">)</span>   </span><br></pre></td></tr></table></figure><div class="note disabled blue flat"><p><div class="tip "><p>为什么要将Counts转变成TPM?</p></div><br>TPM (Transcripts Per Kilobase Million)  每千个碱基的转录每百万映射读取的Transcripts&lt;/br&gt;<br>首先,我们要明确计算TPM是在干嘛，其实就是在归一化。&lt;/br&gt;<br>那它归一对象是谁呢？&lt;/br&gt;</p><script type="math/tex; mode=display">TPM = \frac{\frac{Count}{Length/1000}}{\sum{\frac{Count}{Length/1000}}} \times 10^6</script><p>从TPM的计算公式中我们不难发现涉及到了Count和Length：<span class='p red'>reads</span></p><ul><li>Count：Count 是测序的原始读取数。由于不同的样本可能有不同的测序深度（即测序的总读取数不同），我们需要对 Count 进行归一化，以消除测序深度的影响。这样，我们就可以在同一水平上比较<span class='p red'>不同样本</span>的基因表达量。</li><li>Length：在 RNA-seq 实验中，RNA 分子被打断成较短的片段进行测序。因此，长的基因会有更多的片段可以被测序，从而在测序数据中产生更多的 reads。但这并不意味着长的基因在生物体中就一定表达得更多。因此，我们需要对基因长度进行归一化，以消除基因长度的影响。这样，我们就可以在同一水平上比较<span class='p red'>不同长度</span>的基因的表达量。</li></ul></div><h3 id="基因ID转换并过滤低表达基因"><a href="#基因ID转换并过滤低表达基因" class="headerlink" title="基因ID转换并过滤低表达基因"></a>基因ID转换并过滤低表达基因</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">g2s <span class="operator">&lt;-</span> fread<span class="punctuation">(</span><span class="string">&quot;./data/g2s_vm25_gencode.txt&quot;</span><span class="punctuation">,</span>header <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">,</span>data.table <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span></span><br><span class="line">colnames<span class="punctuation">(</span>g2s<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;geneid&quot;</span><span class="punctuation">,</span><span class="string">&quot;symbol&quot;</span><span class="punctuation">)</span></span><br><span class="line">symbol <span class="operator">&lt;-</span> g2s<span class="punctuation">[</span>match<span class="punctuation">(</span>rownames<span class="punctuation">(</span>counts<span class="punctuation">)</span><span class="punctuation">,</span>g2s<span class="operator">$</span>geneid<span class="punctuation">)</span><span class="punctuation">,</span><span class="string">&quot;symbol&quot;</span><span class="punctuation">]</span> <span class="comment">#匹配counts行名对应的symbol</span></span><br><span class="line">table<span class="punctuation">(</span>duplicated<span class="punctuation">(</span>symbol<span class="punctuation">)</span><span class="punctuation">)</span>  <span class="comment">#统计重复基因名</span></span><br><span class="line">counts <span class="operator">&lt;-</span> aggregate<span class="punctuation">(</span>counts<span class="punctuation">,</span> by<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span>symbol<span class="punctuation">)</span><span class="punctuation">,</span> FUN<span class="operator">=</span><span class="built_in">sum</span><span class="punctuation">)</span></span><br><span class="line">counts <span class="operator">&lt;-</span> column_to_rownames<span class="punctuation">(</span>counts<span class="punctuation">,</span><span class="string">&#x27;Group.1&#x27;</span><span class="punctuation">)</span></span><br><span class="line">tpm <span class="operator">&lt;-</span> aggregate<span class="punctuation">(</span>tpm<span class="punctuation">,</span> by<span class="operator">=</span><span class="built_in">list</span><span class="punctuation">(</span>symbol<span class="punctuation">)</span><span class="punctuation">,</span> FUN<span class="operator">=</span><span class="built_in">sum</span><span class="punctuation">)</span> <span class="comment">###使用aggregat 将symbol列中的相同基因进行合并 </span></span><br><span class="line">tpm <span class="operator">&lt;-</span> column_to_rownames<span class="punctuation">(</span>tpm<span class="punctuation">,</span><span class="string">&#x27;Group.1&#x27;</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">### filter</span></span><br><span class="line">filter_gene <span class="operator">&lt;-</span> rowSums<span class="punctuation">(</span>counts<span class="operator">&gt;</span><span class="number">1</span><span class="punctuation">)</span> <span class="operator">&gt;=</span> <span class="number">2</span></span><br><span class="line">table<span class="punctuation">(</span>filter_gene<span class="punctuation">)</span> </span><br><span class="line">counts_filt <span class="operator">&lt;-</span> counts<span class="punctuation">[</span>filter_gene<span class="punctuation">,</span> <span class="punctuation">]</span> <span class="comment">#替换counts为筛选后的基因矩阵（保留较高表达量的基因）</span></span><br><span class="line">tpm_filt <span class="operator">&lt;-</span> tpm<span class="punctuation">[</span>filter_gene<span class="punctuation">,</span> <span class="punctuation">]</span></span><br></pre></td></tr></table></figure><h2 id="从salmon输出文件中获取counts矩阵"><a href="#从salmon输出文件中获取counts矩阵" class="headerlink" title="从salmon输出文件中获取counts矩阵"></a>从salmon输出文件中获取counts矩阵</h2><p>这部分开始不直接传大段代码了，感觉意义不大，反正也是从别人那照抄，也不方便自己日后查找，主要放一些核心代码、记录方法和思路&lt;/br&gt;<br>tximport从各种外部软件输出中导入转录水平估计值，并选择性地将丰度、计数和转录本长度汇总到基因水平（默认）或输出转录水平基质<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tximport<span class="punctuation">(</span>files<span class="punctuation">,</span> type <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;none&quot;</span><span class="punctuation">,</span> <span class="string">&quot;kallisto&quot;</span><span class="punctuation">,</span> <span class="string">&quot;salmon&quot;</span><span class="punctuation">,</span> <span class="string">&quot;sailfish&quot;</span><span class="punctuation">,</span> <span class="string">&quot;rsem&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">\</span></span><br><span class="line">countsFromAbundance <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;no&quot;</span><span class="punctuation">,</span> <span class="string">&quot;scaledTPM&quot;</span><span class="punctuation">,</span> <span class="string">&quot;lengthScaledTPM&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="punctuation">\</span></span><br><span class="line">tx2gene <span class="operator">=</span> <span class="literal">NULL</span><span class="punctuation">,</span> reader <span class="operator">=</span> read.delim<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><br><details class="folding-tag" yellow><summary> 查看方法参数 </summary>              <div class='content'>              <ul><li>files：salmon输出的quant.sf文件</li><li>type：用于生成丰度的软件类型，例如”kallisto”, “salmon”, “sailfish”, “rsem”</li><li>tx2gene:将转录本 ID（第 1 列）链接到基因 ID（第 2 列）的两列 Data.Frame（顺序不可换）</li><li>reader：可以用外部的read方法来提高提取速度</li></ul>              </div>            </details><br><div class="reference-source"><span class="hidden-anchor" id="referfrom_"></span><a class="reference-anchor" href="#referto_"><div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href=" https://rdocumentation.org/packages/tximport/versions/1.0.3/topics/tximport"> tximport官方文档</a></div></p><hr><h1 id="差异表达分析"><a href="#差异表达分析" class="headerlink" title="差异表达分析"></a>差异表达分析</h1><h2 id="数据检查"><a href="#数据检查" class="headerlink" title="数据检查"></a>数据检查</h2><h3 id="归一化"><a href="#归一化" class="headerlink" title="归一化"></a>归一化</h3><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#log对tpm归一化</span></span><br><span class="line">dat <span class="operator">&lt;-</span> <span class="built_in">log</span><span class="punctuation">(</span>tpm<span class="operator">+</span><span class="number">1</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment">#构建DESeq对象</span></span><br><span class="line">dds <span class="operator">&lt;-</span> DESeqDataSetFromMatrix<span class="punctuation">(</span>countData <span class="operator">=</span> readcounts<span class="punctuation">,</span></span><br><span class="line">                              colData <span class="operator">=</span> groupinfo<span class="punctuation">,</span></span><br><span class="line">                              design <span class="operator">=</span> <span class="operator">~</span> group_list<span class="punctuation">)</span></span><br><span class="line">rld <span class="operator">&lt;-</span> rlog<span class="punctuation">(</span>dds<span class="punctuation">,</span> blind<span class="operator">=</span><span class="literal">FALSE</span><span class="punctuation">)</span> <span class="comment">#rlog进行归一化</span></span><br><span class="line">dat <span class="operator">&lt;-</span> as.data.frame<span class="punctuation">(</span>assay<span class="punctuation">(</span>rld<span class="punctuation">)</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure><h3 id="作图检查"><a href="#作图检查" class="headerlink" title="作图检查"></a>作图检查</h3><ul><li>箱图<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boxplot<span class="punctuation">(</span>dat<span class="punctuation">,</span>col<span class="operator">=</span>color<span class="punctuation">,</span> ylab<span class="operator">=</span><span class="string">&quot;dat&quot;</span><span class="punctuation">,</span> main<span class="operator">=</span><span class="string">&quot; normalized data &quot;</span><span class="punctuation">,</span></span><br><span class="line">        outline <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">,</span> notch <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li><li>样本hclust图<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li><li>距离热图<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">sampleDists <span class="operator">&lt;-</span> dist<span class="punctuation">(</span>t<span class="punctuation">(</span>dat<span class="punctuation">)</span><span class="punctuation">)</span>   <span class="comment">#dist默认计算矩阵行与行的距离， 因此需要转置</span></span><br><span class="line">sampleDistMatrix <span class="operator">&lt;-</span> as.matrix<span class="punctuation">(</span>sampleDists<span class="punctuation">)</span>  </span><br><span class="line">colors <span class="operator">&lt;-</span> colorRampPalette<span class="punctuation">(</span> rev<span class="punctuation">(</span>brewer.pal<span class="punctuation">(</span><span class="number">9</span><span class="punctuation">,</span> <span class="string">&quot;Blues&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="punctuation">)</span><span class="punctuation">(</span><span class="number">255</span><span class="punctuation">)</span>  <span class="comment">#选取热图的颜色</span></span><br><span class="line">p0 <span class="operator">&lt;-</span> pheatmap<span class="operator">::</span>pheatmap<span class="punctuation">(</span>sampleDistMatrix<span class="punctuation">,</span></span><br><span class="line">                         fontsize<span class="operator">=</span><span class="number">7</span><span class="punctuation">,</span></span><br><span class="line">                         clustering_distance_rows<span class="operator">=</span>sampleDists<span class="punctuation">,</span></span><br><span class="line">                         clustering_distance_cols<span class="operator">=</span>sampleDists<span class="punctuation">,</span></span><br><span class="line">                         angle_col<span class="operator">=</span><span class="number">45</span><span class="punctuation">,</span></span><br><span class="line">                         col<span class="operator">=</span>colors<span class="punctuation">)</span></span><br></pre></td></tr></table></figure></li><li>PCA图<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">group_list <span class="operator">&lt;-</span> groupinfo<span class="operator">$</span>group_list</span><br><span class="line">dat.pca <span class="operator">&lt;-</span> PCA<span class="punctuation">(</span>t<span class="punctuation">(</span>dat<span class="punctuation">)</span> <span class="punctuation">,</span> graph <span class="operator">=</span> <span class="built_in">F</span><span class="punctuation">)</span> </span><br><span class="line">percentVar <span class="operator">&lt;-</span> dat.pca<span class="operator">$</span>eig<span class="punctuation">[</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">]</span></span><br><span class="line">pca <span class="operator">&lt;-</span> fviz_pca_ind<span class="punctuation">(</span>dat.pca<span class="punctuation">,</span></span><br><span class="line">                    title <span class="operator">=</span> <span class="string">&quot;Principal Component Analysis&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    legend.title <span class="operator">=</span> <span class="string">&quot;Groups&quot;</span><span class="punctuation">,</span></span><br><span class="line">                    geom.ind <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;point&quot;</span><span class="punctuation">,</span> <span class="string">&quot;text&quot;</span><span class="punctuation">)</span><span class="punctuation">,</span> </span><br><span class="line">                    pointsize <span class="operator">=</span> <span class="number">1.5</span><span class="punctuation">,</span></span><br><span class="line">                    labelsize <span class="operator">=</span> <span class="number">4</span><span class="punctuation">,</span></span><br><span class="line">                    col.ind <span class="operator">=</span> group_list<span class="punctuation">,</span> <span class="comment"># 分组上色</span></span><br><span class="line">                    axes.linetype<span class="operator">=</span><span class="literal">NA</span><span class="punctuation">,</span>  </span><br><span class="line">                    mean.point<span class="operator">=</span><span class="built_in">F</span> <span class="comment"># 去除分组中心点</span></span><br><span class="line"><span class="punctuation">)</span> <span class="operator">+</span> </span><br><span class="line">  coord_fixed<span class="punctuation">(</span>ratio <span class="operator">=</span> <span class="number">1</span><span class="punctuation">)</span> <span class="operator">+</span>  <span class="comment"># 坐标轴的纵横比</span></span><br><span class="line">  xlab<span class="punctuation">(</span>paste0<span class="punctuation">(</span><span class="string">&quot;PC1 (&quot;</span><span class="punctuation">,</span> <span class="built_in">round</span><span class="punctuation">(</span>percentVar<span class="punctuation">[</span><span class="number">1</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;%)&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span>  </span><br><span class="line">  ylab<span class="punctuation">(</span>paste0<span class="punctuation">(</span><span class="string">&quot;PC2 (&quot;</span><span class="punctuation">,</span> <span class="built_in">round</span><span class="punctuation">(</span>percentVar<span class="punctuation">[</span><span class="number">2</span><span class="punctuation">]</span><span class="punctuation">,</span> <span class="number">1</span><span class="punctuation">)</span><span class="punctuation">,</span> <span class="string">&quot;%)&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span>  </span><br></pre></td></tr></table></figure></li><li>差异基因热图 <figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li><li>相关性热图<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习📚 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生信 </tag>
            
            <tag> 代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>还没开始复现 这只是一个测试</title>
      <link href="/2024/05/11/share1/"/>
      <url>/2024/05/11/share1/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 文章复现👨‍💻 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 蛋白质设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>欢迎光临Eddie的blog</title>
      <link href="/2024/05/10/welcome/"/>
      <url>/2024/05/10/welcome/</url>
      
        <content type="html"><![CDATA[<h1 id="Welcome-to-Eddie’s-blog"><a href="#Welcome-to-Eddie’s-blog" class="headerlink" title="Welcome to Eddie’s blog!"></a>Welcome to Eddie’s blog!</h1><p>本博客基于Hexo+Github搭建，采用butterfly主题样式。由于能力受限，做的很丑hhhh<br>这是我的第一篇博客，也可能没有第二篇<br>如果有第二篇的话，那就有吧hhh<br>希望有机会能在上面分享我的学习记录（仅代表个人的理解，可能希望对大家有帮助，也有可能误导大家笑死）</p><style>refer .a {    color: white;    font-size: 8px;    text-decoration: none;}refer a:hover {    color: blue;}</style><p>记录一下学习RNA-seq分析的过程，整体流程参考，可能会补充一些其他的资料：</p><refer><ul><li> <a href="https://zhuanlan.zhihu.com/p/518132262">RNA-seq入门实战（零）：RNA-seq流程前的准备——Linux与R的环境创建</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518134934">RNA-seq入门实战（一）：上游数据下载、格式转化和质控清洗</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518137593">RNA-seq入门实战（二）：上游数据的比对计数——Hisat2+ featureCounts 与 Salmon</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518140221">RNA-seq入门实战（三）：从featureCounts与Salmon输出文件获取counts矩阵</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518141288">RNA-seq入门实战（四）：差异分析前的准备——数据检查</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518142469">RNA-seq入门实战（五）：差异分析——DESeq2 edgeR limma的使用与比较</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518143539">RNA-seq入门实战（六）：GO、KEGG富集分析与enrichplot超全可视化攻略</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518144716">RNA-seq入门实战（七）：GSEA——基因集富集分析</a></li><li> <a href="https://zhuanlan.zhihu.com/p/518145829">RNA-seq入门实战（八）：GSVA——基因集变异分析</a></li><li> <a href="https://zhuanlan.zhihu.com/p/532037554">RNA-seq入门实战（九）：PPI蛋白互作网络构建（上）——STRING数据库的使用</a></li><li> <a href="https://zhuanlan.zhihu.com/p/532038640">RNA-seq入门实战（十）：PPI蛋白互作网络构建（下）——Cytoscape软件的使用</a></li><li> <a href="https://zhuanlan.zhihu.com/p/532039670">RNA-seq入门实战（十一）：WGCNA加权基因共表达网络分析——关联基因模块与表型</a></li></ul></refer>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
